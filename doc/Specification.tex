\documentclass{report}

\def\version{0.0.1}

\usepackage{verbatim}

\begin{document}

\title{Bannker - Technical Specification}
\author{Nicholas LeCompte}
\date{2020 \\ \version}
\maketitle

\begin{abstract}
    This technical report 
\end{abstract}

\chapter{Introduction}

\chapter{Module definitions}

A Banneker program is associated to a \emph{module}, which defines the various ``types of types'' used in the program, along with .
\begin{verbatim}
module MyProgram = {
    sorts = {MyType, MyProp}
    axioms = {(MyProp:MyType)}
    rules = {
        (MyType:MyType:MyType),
        (MyProp:MyType:MyType),
        (MyType:MyProp:MyProp),
        (MyProp:MyProp:MyProp)
    }
    with_import = {MyOtherProgram}
}
\end{verbatim}

The collection (\texttt{sorts},\texttt{axioms},\texttt{rules}) is called a \emph{specification}. Banneker comes with many built-in specifications:
\begin{itemize}
    \item $\texttt{untyped}: \texttt{sorts = }$
    \item $\texttt{simply\_typed}$
\end{itemize}

One can also define \emph{inductive} families of sorts. A common example is a type hierarchy, eg, $\{\texttt{Type},\texttt{Type} \rightarrow \texttt{Type},\texttt{Type} \rightarrow (\texttt{Type} \rightarrow \texttt{Type}, \ldots \}$

\chapter{Defining new sort instances}

\chapter{Classes and contexts}

Among the collection of types in Banneker is a subcollection, which we will call the \emph{category of object-oriented classes}, following the theory specified in the Banneker Technical Overview. Although the term ``class'' is rather overloaded in mathematical logic, here we use it exclusively to mean in the common sense of typical object-oriented languages and paradigms. As in Java, Python, and so on, classes are ``mixes'' of data and functions.

Banneker largely implements members as syntactial sugar. [define the explicit module member that is cretaed]

If $\texttt{Type}$ (resp. $\texttt{Type}_0$) is defined among the sorts, then classes are automatically taken as members of $\texttt{Type}$ (resp. $\texttt{Type}_0$). Otherwise this relation must be specified if classes are used in the program; it may also be overridden:

\begin{equation*}
    \textt{sorts = [AlgebraicType,Type]}
    \texttt{rules = [AlgebraicType:Type]}
    \textt{class = AlgebraicType}
\end{equation*}

\end{document}